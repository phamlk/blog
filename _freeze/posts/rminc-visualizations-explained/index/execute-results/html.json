{
  "hash": "52dea87beac924377f78e70360b631f8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Under the hood: visualizations in RMINC\"\ndescription: \"How RMINC projects and visualizes results using a sample cross-sectional comparison.\"\nauthor: \"Linh Pham and Jason Lerch\"\ndate: \"2025/07/30\"\ndate-modified: \"2025/07/30\"\ncategories: [RMINC]\ndraft: false\nengine: knitr\nnumber-selections: false\n---\n\n\n\nRMINC visualization tools are versatile, but how the results are visualized are not super obvious. Here, I'm demonstrating a little bit of what's happening under the hood using Four Core Genotype rat data that Myrto Lavda had gathered. \n\nMyrto had surgically induced strokes on some of these animals to understand how sex hormones and chromosomes impact stroke outcomes in the brain. We will be comparing the difference in volume between rats of different genotypes and stages of the stroke experiment. \n\n\n\n::: {.cell}\n\n:::\n\n\n\n# Set up \n\nReading in necessary packages \n\n\n::: {.cell}\n\n```{.r .cell-code}\npackages <- c(\"tidyverse\", \"RMINC\", \"MRIcrotome\", \"broom\", \"forcats\", \"gridExtra\", \"lspline\", \"emmeans\", \"png\", \"Cairo\", \"ggplot2\", \"rstatix\")\n\ninvisible(sapply(packages, function(x) library(x, character.only = TRUE)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n\nAttaching package: 'MRIcrotome'\n\n\nThe following object is masked from 'package:graphics':\n\n    legend\n\n\n\nAttaching package: 'gridExtra'\n\n\nThe following object is masked from 'package:dplyr':\n\n    combine\n\n\nWelcome to emmeans.\nCaution: You lose important information if you filter this package's results.\nSee '? untidy'\n\n\nAttaching package: 'rstatix'\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n```\n\n\n:::\n:::\n\n\n\n# Reading in the data\n\nThe output of a PydPiper pipeline includes different types of Jacobian determinants for each image. The full Jacobian (log_full_det) is used when one's interested in volumetric effects and not accounting for total brain volume (TBV). Nonlinear Jacobian (log_nlin_det) is used when TBV should be accounted.\n\nPydPiper saves these determinants after different levels of blurring have been applied to them at each voxel. A FWHM blur of 0.2 is usually used when the analyses are at the voxel level. FWHM of 0 (no blurring) is used when analyses are done at the regional level (since noise from voxel-wise determinants can be reduced when the voxels determinants are averaged/combined to make a regional volume).\n\nThe code below reads in a csv, produced from PydPiper pipeline, that indicates where the determinant files for each image/animal are located. Files with FWHM 0.2 are chosen because analyses will be done at the voxel level. Some text manipulations are done to animal ID and time point for ease of analyses later on. A new variable, 'stage', is made to determine if the animal was scanned at baseline, after acute stroke, or doing recovery using their file names.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npipeout <- read_csv(\"/well/lerch/users/dqp841/FCG_Rat_Stroke/pipelines/analysis.csv\") %>% \n  dplyr::filter(fwhm==0.2)%>%\n  mutate(Animal.ID = basename(log_nlin_det), # the following lines are modifying animal IDs and category to make them suitable for subsequent analyses \n         Animal.ID = str_replace(Animal.ID, \"RNC4\", \"RNEC4\"),\n         Animal.ID = str_replace(Animal.ID, \"RNEC4_1_Base\", \"RNEC4_1c_Base\"),\n         Animal.ID = str_replace(Animal.ID, \"RNEC1_1b\", \"RNEC3_1b\"),\n         Animal.ID = gsub('.+Stroke_(.+_.+)_[PBF].+', '\\\\1',Animal.ID),\n         timepoint = str_split(Animal.ID, \"_\") %>% map_chr(.,~ifelse(length(.x)>2, .x[3], \"PS3\")),\n         timepoint = ifelse(timepoint == \"a\", \"Baseline\", timepoint),\n         timepoint = ifelse(timepoint == \"b\", \"Baseline\", timepoint),\n         Animal.ID = str_split(Animal.ID, \"_\") %>% map_chr(.,~paste(.x[1],.x[2],sep=\".\")),\n         stage = case_when(str_detect(log_nlin_det, \"Baseline\") ~ \"baseline\",\n      str_detect(log_nlin_det, \"baseline\") ~ \"baseline\",\n      str_detect(log_nlin_det, \"PS37\") ~ \"recovery\",\n      str_detect(log_nlin_det, \"Recovery\") ~ \"recovery\",\n      str_detect(log_nlin_det, \"PS30\") ~ \"recovery\",\n      str_detect(log_nlin_det, \"PS3\\\\d\") ~ \"recovery\",\n      str_detect(log_nlin_det, \"PS3\") ~ \"acute\",\n      str_detect(log_nlin_det, \"RNEC3_1a_FCGStro\") ~ \"acute\",\n      str_detect(log_nlin_det, \"RNEC1_1b\") ~ \"acute\",\n      TRUE ~ \"undetected\"\n    ))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 216 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (11): rigid_xfm, lsq12_nlin_xfm, overall_xfm, native_file, lsq6_file, ls...\ndbl  (1): fwhm\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(pipeout)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 15\n  rigid_xfm      lsq12_nlin_xfm overall_xfm native_file lsq6_file lsq6_mask_file\n  <chr>          <chr>          <chr>       <chr>       <chr>     <chr>         \n1 FCGRat-t2-202… FCGRat-t2-202… FCGRat-t2-… /well/lerc… FCGRat-t… FCGRat-t2-202…\n2 FCGRat-t2-202… FCGRat-t2-202… FCGRat-t2-… /well/lerc… FCGRat-t… FCGRat-t2-202…\n3 FCGRat-t2-202… FCGRat-t2-202… FCGRat-t2-… /well/lerc… FCGRat-t… FCGRat-t2-202…\n4 FCGRat-t2-202… FCGRat-t2-202… FCGRat-t2-… /well/lerc… FCGRat-t… FCGRat-t2-202…\n5 FCGRat-t2-202… FCGRat-t2-202… FCGRat-t2-… /well/lerc… FCGRat-t… FCGRat-t2-202…\n6 FCGRat-t2-202… FCGRat-t2-202… FCGRat-t2-… /well/lerc… FCGRat-t… FCGRat-t2-202…\n# ℹ 9 more variables: nlin_file <chr>, nlin_mask_file <chr>, fwhm <dbl>,\n#   log_nlin_det <chr>, log_full_det <chr>, label_file <chr>, Animal.ID <chr>,\n#   timepoint <chr>, stage <chr>\n```\n\n\n:::\n:::\n\n\n\nReading in animal meta information.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# reading in the data and keeping only IDs that are unique (removing duplicates essentially)\nratinfo <- read_csv(\"/well/lerch/users/dqp841/FCG_Rat_Stroke/analyses/Master_Data_File - info-all_clean.csv\") %>% distinct(`Animal ID`, .keep_all = TRUE) %>% rename(Animal.ID = `Animal ID`)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 36 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): Animal ID, Sex, Genotype\ndbl (7): #, Age (Baseline), Age (Acute), Age (Recovery), Weight (Baseline), ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\n# now we need to join the pipeout data frame with rat info data frame by animal ID. first, we need to see if the ID matches up across pipeout and rat info. \nhead(pipeout$Animal.ID)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"RNEC4.1a\" \"RNEC4.1d\" \"RNEC4.1f\" \"RNEC3.1b\" \"RNEC1.1g\" \"RNEC1.1g\"\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(ratinfo$Animal.ID)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"RNEC1.1p\" \"RNEC1.1m\" \"RNEC1.1n\" \"RNEC4.1j\" \"RNEC4.1i\" \"RNEC4.1l\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# looks the same. joining them together. setting the stage variable as a factor variable with hierarchy baseline, acute, recovery. adding full paths to log_nlin_det, log_full_det, and label_file. \ngf <- left_join(pipeout, ratinfo, by=\"Animal.ID\") %>%\n  mutate(stage = factor(stage, levels=c(\"baseline\", \"acute\", \"recovery\")),\n         genotype = factor(Genotype, levels=c(\"XX\", \"XY\", \"XYSry\", \"XXSry\")),\n         log_nlin_det = paste0(\"/well/lerch/users/dqp841/FCG_Rat_Stroke/pipelines/\", log_nlin_det),\n         log_full_det = paste0(\"/well/lerch/users/dqp841/FCG_Rat_Stroke/pipelines/\", log_full_det),\n         label_file=paste0(\"/well/lerch/users/dqp841/FCG_Rat_Stroke/pipelines/\", label_file))\n\n#  getting a summary output of the genotype and stages\ngf %>% group_by(genotype, stage) %>% summarise(count = n()) %>% pivot_wider(names_from = stage, values_from = count, id_cols = \"genotype\") %>% mutate(Sum = rowSums(across(where(is.numeric))))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'genotype'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n# Groups:   genotype [4]\n  genotype baseline acute recovery   Sum\n  <fct>       <int> <int>    <int> <dbl>\n1 XX              9     9        9    27\n2 XY              9     9        9    27\n3 XYSry          10    10       10    30\n4 XXSry           8     8        8    24\n```\n\n\n:::\n:::\n\n\n\nReading in the consensus/averaged segmented image generated after nonlinear transformation round 3 (nlin-3). This will be used downstream as a mask to indicate which voxels in the images can be used to make linear models.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmask <- \"/well/lerch/users/dqp841/FCG_Rat_Stroke/pipelines/FCGRat-t2-2024-10-03_nlin/FCGRat-t2-2024-10-03-nlin-3/FCGRat-t2-2024-10-03-nlin-3_voted.mnc\"\n```\n:::\n\n\n\n## Analyses\n\nIn the following examples, different types of models are fitted to answer some very specific questions. \n\n### Simple case: vs_genotype model\n\nHere, the [mincLm function](https://rdrr.io/github/Mouse-Imaging-Centre/RMINC/man/mincLm.html) from the RMINC package is used. This function allows you to fit a linear model across all voxels in the data.\n\nThe model is addressing this question: which voxels show statistically significant volumetric differences between the genotypes at the baseline time point?\n\nNotice the mask imported earlier is used here to help mincLm determine which voxels in the images that can be included for linear modeling.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# note that this is using the log_full_determinants. total brain volume are not accounted for in this model. to do that, you'd use relative determinants. \nvs_genotype <- mincLm(log_full_det ~ genotype, gf %>% dplyr::filter(stage == \"baseline\"), mask=mask)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMethod: lm\nNumber of volumes: 36\nVolume sizes: 67 131 85\nN: 36 P: 4\nIn slice \n 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66 \nDone\n```\n\n\n:::\n:::\n\n\n\nI want to explore the outputs of vs_genotype and build up my understanding of what's available for visualization purposes from there.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# what's in vs_genotype \ncolnames(vs_genotype)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"F-statistic\"          \"R-squared\"            \"beta-(Intercept)\"    \n [4] \"beta-genotypeXY\"      \"beta-genotypeXYSry\"   \"beta-genotypeXXSry\"  \n [7] \"tvalue-(Intercept)\"   \"tvalue-genotypeXY\"    \"tvalue-genotypeXYSry\"\n[10] \"tvalue-genotypeXXSry\" \"logLik\"              \n```\n\n\n:::\n\n```{.r .cell-code}\nhead(vs_genotype)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     F-statistic R-squared beta-(Intercept) beta-genotypeXY beta-genotypeXYSry\n[1,]           0         0                0               0                  0\n[2,]           0         0                0               0                  0\n[3,]           0         0                0               0                  0\n[4,]           0         0                0               0                  0\n[5,]           0         0                0               0                  0\n[6,]           0         0                0               0                  0\n     beta-genotypeXXSry tvalue-(Intercept) tvalue-genotypeXY\n[1,]                  0                  0                 0\n[2,]                  0                  0                 0\n[3,]                  0                  0                 0\n[4,]                  0                  0                 0\n[5,]                  0                  0                 0\n[6,]                  0                  0                 0\n     tvalue-genotypeXYSry tvalue-genotypeXXSry logLik\n[1,]                    0                    0      0\n[2,]                    0                    0      0\n[3,]                    0                    0      0\n[4,]                    0                    0      0\n[5,]                    0                    0      0\n[6,]                    0                    0      0\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(vs_genotype)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 746045     11\n```\n\n\n:::\n:::\n\n\n\nSo the results from mincLm seems to include the beta coefficients (differences) in log_full_determinants between XX and the other genotypes at baseline (XX is not present, so it's serving as the reference variable for all comparisons), and t-statistics associated with the difference between XX and the other genotypes.\n\nIf you want to see whether XY is different from the other genotypes, for example, you would need to refactor the data. Sample code below (this code is not run).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngf %>% genotype = factor(Genotype, levels=c(\"XY\", \"XX\", \"XYSry\", \"XXSry\"))\n```\n:::\n\n\n\nThere are 746,045 voxels where these statistics are available. That's too many comparisons, and we run the risk of having voxels that are not actually different between the groups deemed significant (false positives). Multiple comparison adjustments need to be done.\n\nThis is where [mincFDR](https://rdrr.io/github/Mouse-Imaging-Centre/RMINC/man/mincFDR.html) comes in. mincFDR takes a mincLm object as an input, and then (I think) it: 1) converts the t-values in mincLm to p-values and 2) applies the `p.adjust` function to all voxels, taking into account how many voxels there are in total.\n\nLet's apply mincFDR to our simple model and see its outputs. I'm calling it vs_genotype_qvals because after FDR adjustments, p-values are called q-values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvs_genotype_qvals <- mincFDR(vs_genotype)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nComputing FDR threshold for all columns\n  Computing threshold for  F-statistic \n  Computing threshold for  tvalue-(Intercept) \n  Computing threshold for  tvalue-genotypeXY \n  Computing threshold for  tvalue-genotypeXYSry \n  Computing threshold for  tvalue-genotypeXXSry \n```\n\n\n:::\n\n```{.r .cell-code}\nhead(vs_genotype_qvals)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     qvalue-F-statistic qvalue-tvalue-(Intercept) qvalue-tvalue-genotypeXY\n[1,]                  1                         1                        1\n[2,]                  1                         1                        1\n[3,]                  1                         1                        1\n[4,]                  1                         1                        1\n[5,]                  1                         1                        1\n[6,]                  1                         1                        1\n     qvalue-tvalue-genotypeXYSry qvalue-tvalue-genotypeXXSry\n[1,]                           1                           1\n[2,]                           1                           1\n[3,]                           1                           1\n[4,]                           1                           1\n[5,]                           1                           1\n[6,]                           1                           1\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(vs_genotype_qvals)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 746045      5\n```\n\n\n:::\n:::\n\n\n\nSo you get a matrix with the same number of voxels (rows) as your input model and some columns labeled `qvalue-tvalue-genotype`. I suspect that these are the going to be the adjusted p-values (or q-values) you'll want to visualize on your atlases!\n\nLet's just double check that's the case. I'm checking the range of these q-value columns. If they're all between 0 and 1, that would mean they are in fact adjusted p-values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# apply the function (range) to all columns in vs_genotype_qvals \nsapply(1:ncol(vs_genotype_qvals), function(x) range(vs_genotype_qvals[,x]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             [,1]         [,2]      [,3]         [,4]        [,5]\n[1,] 0.0006884425 2.438496e-07 0.0061084 9.327254e-05 0.006208024\n[2,] 1.0000000000 1.000000e+00 1.0000000 1.000000e+00 1.000000000\n```\n\n\n:::\n:::\n\n\n\nNice! They're all 0 - 1. That means they're all adjusted p-values, and there is a way to visualize these on your atlases.\n\n## Visualizations\n\nTo do our visualizations, we need a couple more things. First, a template image so the statistics visualizations can be laid on top of it. Here we're using the average nlin-3 image from the pipeline.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlin <- mincArray(mincGetVolume(\"/well/lerch/users/dqp841/FCG_Rat_Stroke/pipelines/FCGRat-t2-2024-10-03_nlin/FCGRat-t2-2024-10-03-nlin-3.mnc\"))\n\ndim(nlin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  85 131  67\n```\n\n\n:::\n:::\n\n\n\nThen, the atlas labels of the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# using the 'mask' file again because it's actually the labelled atlas. \nlabelVol <- mincArray(mincGetVolume(mask))\n\ndim(labelVol)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  85 131  67\n```\n\n\n:::\n:::\n\n\n\nNotice when I print the dimensions of nlin and labelVol, they are exactly the same. That's because nlin is the nlin-3 image, and labelVol is the labels of the nlin-3 image (nlin-3_voted).\n\nBoth files have 85 slices in the x-axis, 131 slices in the y-axis, and 67 slices in the z-axis.\n\nLet's look at an example slice from these data matrices to see what information they're storing.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pull a sample of the matrix representing voxels in slice 30 of z-axis in nlin and labelVol\nnlin[, ,30 ][35,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1]   75.00039   93.25433  126.19213  167.79124  203.70927  221.99425\n  [7]  277.62530  472.76857  981.20899 1431.31753 1611.21815 1604.14009\n [13] 1378.85299 1197.64852 1150.36834 1136.08805 1074.49654 1026.50235\n [19] 1050.93406 1037.64718 1036.77795 1168.96376 1372.70625 1338.99235\n [25]  945.19782  782.15416  816.70626  794.91329  866.19057  873.33071\n [31]  800.22183  765.54556  851.78610  973.07543 1016.59928 1039.19939\n [37] 1044.16644  989.55986  983.94087  985.46203  904.62317  829.18599\n [43]  797.14847  777.87007  751.04796  730.83825  735.61904  740.74132\n [49]  757.10157  751.88615  716.68213  717.05466  715.12993  727.42340\n [55]  749.46471  710.93897  838.46818  928.96175  868.42574  861.40977\n [61]  840.20665  840.88962  848.68169  839.02697  828.31675  831.07968\n [67]  814.65734  826.67141  833.50112  780.81926  807.79660  881.12278\n [73]  975.62105  972.70290  955.75282  999.27666 1022.46661 1055.68381\n [79] 1064.81078 1067.97728 1076.60754 1084.08917 1078.43914 1085.17571\n [85] 1079.71195 1092.71943 1156.51508 1161.32691 1090.39112  970.74713\n [91]  888.91485  941.00687 1075.98666 1177.59403 1177.06628 1115.81625\n [97]  869.32602  508.22094  289.85667  218.88984  196.69330  207.12412\n[103]  217.05824  235.71575  254.12490  275.94891  265.26974  252.44852\n[109]  213.79861  211.87387  252.69688  269.02608  292.27812  394.59950\n[115]  490.77415  521.97348  566.58387  563.13797  528.36857  500.33574\n[121]  475.03479  482.54746  452.93138  412.41882  376.87331  362.15841\n[127]  335.18107  318.94501  273.09286  213.98487  126.03691\n```\n\n\n:::\n\n```{.r .cell-code}\nlabelVol[, ,30][35,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1]   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0  29  29  29\n [19]  29  29  29   0   0   0   7 193   7 189 189 189 189   7 189 189 189 189\n [37] 208 208 208 208 208 208 208 208 208 208 208 208 208 208 208 208 208 156\n [55] 156 208 156 156 156 156 156 156 156 156 156 156 156 156 156 156  45  45\n [73]  78  78  50 243  50  50  50  50  50  50  47  47  47  47  95  41  41  41\n [91]  41  41  41  41  41  41   0   0   0   0   0   0   0   0   0   0   0   0\n[109]   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0\n[127]   0   0   0   0   0\n```\n\n\n:::\n:::\n\n\n\nI've pulled out 129 values each from `nlin` and `labelVol`. Each of these values are information contained within a subset of voxels at slice 30 in the z-axis.\n\nIn `nlin`, the voxels are decimal numbers representing image intensity.\n\nIn `labelVol`, the voxels are whole numbers representing an atlas label (i.e. 1 is Hippocampus. I'm just making up the numbers and their associations. Actual associations are likely different).\n\nWith that in mind, I'm gonna annotate the following visualization:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# start a sliceSeries, with 1 row and 5 columns. use slices from the z-axis (default), and plot 5 slices (5 columns) from slices 30 through 90. \nsliceSeries(nrow=1, ncol=5, begin=30, end=90) %>% \n\n# overlay the anatomy image. in our case, is the nlin-3 image. plot voxels that are between 700 to 1400 in their image intensities. \n  anatomy(nlin, low=700, high=1400) %>%\n  \n# overlay the statistics. see explanation below the figure that will be generated\n  overlay(-log10(mincArray(vs_genotype_qvals, \"qvalue-tvalue-genotypeXXSry\")) * (labelVol>0.5) * sign(mincArray(vs_genotype, \"tvalue-genotypeXXSry\")), low=0.1, high=2, symmetric=T) %>% \n\n# add a title\n  addtitle(\"XXSry abs\") %>% \n\n# add a legend \n  legend(\"-log10 q-value\") %>% \n\n# draw the figure! \n  draw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.svg){width=672}\n:::\n:::\n\n\n\n## The statistics overlay\n\nAs a reminder, this was our statistics overlay code for the visualization.\n\n`overlay(-log10(mincArray(vs_genotype_qvals, \"qvalue-tvalue-genotypeXXSry\")) * (labelVol>0.5) * sign(mincArray(vs_genotype, \"tvalue-genotypeXXSry\")), low=0.1, high=2, symmetric=T)`\n\nTo explain how this works , let's break down how it's calculated first. I'm still pulling a sample from slice 30 of z-dimension to be consistent.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# step 1: calculate -log10 of q-values at every voxels. log10 is multipled by negative 1 because log10 gives negative values for anything less than 1. Negative q-values don't make sense. Applying log10 to the q-value is just scaling them up to make visualization easier (seeing the difference between 0 and 2 is easier than 0 and 1) \nlog10_q <- -log10(mincArray(vs_genotype_qvals, \"qvalue-tvalue-genotypeXXSry\"))[, ,30][35,]\n\nlog10_q \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n  [7] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [13] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [19] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [25] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [31] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [37] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [43] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [49] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [55] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [61] 0.20750872 0.35157189 0.44689661 0.39531659 0.29839121 0.28133185\n [67] 0.21447423 0.07332705 0.13295974 0.25733193 0.47530662 0.61956803\n [73] 0.74616107 0.54277334 0.25480405 0.05685436 0.00000000 0.00000000\n [79] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [85] 0.09534905 0.44918051 0.78955389 0.86610506 0.90096597 0.76349428\n [91] 0.40968016 0.23513449 0.01712954 0.00000000 0.00000000 0.00000000\n [97] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n[103] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n[109] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n[115] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n[121] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n[127] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n```\n\n\n:::\n\n```{.r .cell-code}\n# step 2: identify if a voxel is actually inside a region of interest/inside the brain using the following code. in R, TRUE is coded as 1 and FALSE is coded as 0. so imagine the output is a matrix of TRUE/FALSE is also read as a 1/0 matrix. if a voxel is inside the brain/associated with a brain region, it would have an atlas label > 0. hence why this works. \nlabel_in_brain <- labelVol[, ,30][35,]>0.5\nlabel_in_brain \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [49]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [61]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [73]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [85]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# step 3: identify the signs associated with t-values in the voxels. negative means it's lesser volume in the XXSry genotype compared to XX. positive means it's greater in volume for XXSry genotype compared to XX. \ntvals_sign <- sign(mincArray(vs_genotype, \"tvalue-genotypeXXSry\")[, ,30][35,])\ntvals_sign\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1]  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  0  0  0  1\n [26]  1  1  1  1  1  1  1  1  1  1  1 -1 -1 -1  1  1  1  1  1  1  1  1  1  1  1\n [51]  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n [76]  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  0  0  0  0\n[101]  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n[126]  0  0  0  0  0  0\n```\n\n\n:::\n\n```{.r .cell-code}\n# notice these vectors have the same dimension. we're referring to the same voxels across all of these vectors.\nlength(log10_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 131\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(label_in_brain)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 131\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(tvals_sign)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 131\n```\n\n\n:::\n\n```{.r .cell-code}\n# step 4: multiply all three vectors together. these are the values plotted on your visualization. \nsample_qvals_on_map <- log10_q * label_in_brain * tvals_sign\nsample_qvals_on_map\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n  [7] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [13] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [19] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [25] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [31] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [37] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [43] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [49] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [55] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [61] 0.20750872 0.35157189 0.44689661 0.39531659 0.29839121 0.28133185\n [67] 0.21447423 0.07332705 0.13295974 0.25733193 0.47530662 0.61956803\n [73] 0.74616107 0.54277334 0.25480405 0.05685436 0.00000000 0.00000000\n [79] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n [85] 0.09534905 0.44918051 0.78955389 0.86610506 0.90096597 0.76349428\n [91] 0.40968016 0.23513449 0.01712954 0.00000000 0.00000000 0.00000000\n [97] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n[103] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n[109] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n[115] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n[121] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n[127] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000\n```\n\n\n:::\n:::\n\n\n\nNotice that the range of these sample q-values\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrange(sample_qvals_on_map)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.000000 0.900966\n```\n\n\n:::\n:::\n\n\n\nIn this case, they're from 0 to 0.91. Notice in the code, we had this bit \\``` low=0.1, high=2, symmetric=T)` `` . Here, any voxel where the -log10 q-value is below 0.1 is not plotted, and anything beyond 2 is not plotted (assuming the smallest raw q-value is 0.01). If I increase the low threshold to 0.7\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsliceSeries(nrow=1, ncol=5, begin=30, end=90) %>%\n  anatomy(nlin, low=700, high=1400) %>%\n  overlay(-log10(mincArray(vs_genotype_qvals, \"qvalue-tvalue-genotypeXXSry\")) * (labelVol>0.5) * sign(mincArray(vs_genotype, \"tvalue-genotypeXXSry\")), low=0.7, high=2, symmetric=T) %>% legend(\"-log10 q-value\") %>%\n  addtitle(\"XXSry abs\") %>% draw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.svg){width=672}\n:::\n:::\n\n\n\nWhy do we want to have all of these modifications to the original q-values? If you play around with the code and take out `(labelVol>0.5) * sign(mincArray(vs_genotype, \"tvalue-genotypeXXSry\")`, your display will look exactly the same given the slices you've chosen.\n\nBut, if you choose different slices (say instead of between 30 - 90, you pick somewhere closer to beginning or final slices i.e. 110 - 131), where the data is noisier, I would suspect you'll get more inaccurate display of your stats. Just play around and see if this is true!\n\nI hope this will help you have more flexibility in using RMINC to visualize your results. ",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}