{
  "hash": "66ce66e2992de369723588885708988f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Understanding data tree using a toy example\"\nauthor: \"Linh Pham\"\ndescription: \"How to work with and manipulate data trees, such as the RMINC hierarchical anatomy tree\"\ndate: \"2025/08/05\"\ndate-modified: \"2025-08-05\"\ncategories: [RMINC, data tree]\ndraft: false\nengine: knitr\nnumber-sections: false\n---\n\n\n# Working with `data.tree`\n\n`data.tree` is used to organize and manipulate hierarchical data structures in `RMINC`. I'm still not completely comfortable using it, so I'm documenting my process for figuring out how `data.tree` works. \n\nThis blog uses toy example that comes with `data.tree`, but figuring out how things work with the toy example should help me understand how the hierarchical anatomy tree is manipulated in `RMINC`. \n\n\n\n\n\n\n\nExamples from https://cran.r-project.org/web/packages/data.tree/vignettes/data.tree.html\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.tree)\n```\n:::\n\n\n\n# Definitions \n\nThe building block of a data tree is a `Node` object. All operations are based around the `Node`. Each node can store multiple attributes. \nAn attribute can be 1) a field/active associated with the node; 2) a method, or default function, that comes with all nodes made via `data.tree`; 3) a function that you have made and want to tack onto the node. \n\nFor example: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnode$Get(\"attribute\")\n```\n:::\n\n\n\nIn this example, `Get` is a function attribute associated with a node. Because it's a function, it can take different arguments. In this case, the argument is \"attribute\". With `Get`, I'm asking to grab the values under `attribute` for `node` and its children. \n\nIf you're interested in another attribute, such as a variable associated with the node, \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnode$position # grab the position \n```\n:::\n\n\n\nThis syntax will only grab the `position` field associated with the specific node. If one is interested in grabbing the `position` node of the specific field and its children, then the `Get` function comes into play. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnode$Get(\"position\")\n```\n:::\n\n\n\n**In Summary**\n1. Attributes: can be 1) variables associated with a node (like a cell in a column of name x of a data frame); 2) default methods of all nodes; 3) custom methods tacked onto a node. \n2. To get the attributes, the syntax is `node$name_of_attribute`. \n\n# Tree creation\n\n## Create a tree programmatically \n\nMaking a tree programmatically using the example data provided by `data.tree`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# initialize a new node named \"Acme Inc.\"\nacme <- Node$new(\"Acme Inc.\")\nacme \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  levelName\n1 Acme Inc.\n```\n\n\n:::\n\n```{.r .cell-code}\n# adding a child of the acme node, or a branch from it, called \"Accounting\"\naccounting <- acme$AddChild(\"Accounting\")\n# accounting is now its own node entity\naccounting\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   levelName\n1 Accounting\n```\n\n\n:::\n\n```{.r .cell-code}\n# and acme now has an accounting child node appended to it \nacme\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       levelName\n1 Acme Inc.     \n2  °--Accounting\n```\n\n\n:::\n\n```{.r .cell-code}\n# so on and so forth, we add more child nodes. AddChild is one of the default functions/methods\n# that come with each node. \nsoftware <- accounting$AddChild(\"New Software\")\nstandards <- accounting$AddChild(\"New Accounting Standards\")\n\nresearch <- acme$AddChild(\"Research\")\nnewProductLine <- research$AddChild(\"New Product Line\")\nnewLabs <- research$AddChild(\"New Labs\")\n\nit <- acme$AddChild(\"IT\")\noutsource <- it$AddChild(\"Outsource\")\nagile <- it$AddChild(\"Go agile\")\ngoToR <- it$AddChild(\"Switch to R\")\n\nprint(acme) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName\n1  Acme Inc.                       \n2   ¦--Accounting                  \n3   ¦   ¦--New Software            \n4   ¦   °--New Accounting Standards\n5   ¦--Research                    \n6   ¦   ¦--New Product Line        \n7   ¦   °--New Labs                \n8   °--IT                          \n9       ¦--Outsource               \n10      ¦--Go agile                \n11      °--Switch to R             \n```\n\n\n:::\n:::\n\n\nThe whole tree, acme, is a node. It started as a node. Subsequent nodes added are tacked onto the initial node, acme, to build a tree. \n\nNotice their classes are the same. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(acme)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Node\" \"R6\"  \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(it) # randomly chosen node that is not acme \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Node\" \"R6\"  \n```\n\n\n:::\n:::\n\n\n\nThis is different from a data table or data frame, where objects can exist as independent variables, but once they are put into a data frame, the object that stores them, or the data frame, is an entirely different class than the independent variables. \n\nThe same node can be referred to in multiple ways. For example, `it` and `acme$IT` refer to the same thing. \n\nThe tree root is always that first node where everything else is built upon. In this case, the root is `acme`. Leaves are the final branches in a tree. We can see which node is a root or a leaf by using the function attributes `isLeaf` or `isRoot`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacme$isRoot\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nacme$Accounting$isRoot\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nacme$Accounting$isLeaf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nacme$Accounting$`New Software`$isLeaf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\nCurrently, the only attributes associated with the nodes are their names and some default functions that are associated with all nodes. Let's take a look at the syntax. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nit$Get(\"name\") # grab it's attribute function Get and use it to retrieve the name associated with node it and its children. \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           IT     Outsource      Go agile   Switch to R \n         \"IT\"   \"Outsource\"    \"Go agile\" \"Switch to R\" \n```\n\n\n:::\n\n```{.r .cell-code}\nit$name # grab it node's attribute name, which will show only its name on the node\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"IT\"\n```\n\n\n:::\n\n```{.r .cell-code}\nit[[\"name\"]] # this also grabs just the node's attribute, name, at that specific node. \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"IT\"\n```\n\n\n:::\n:::\n\n\n\n## Adding custom attributes to a tree\nThink of these like adding columns of data to associate with each node i.e. if you're working with brain regions, `volumes` is an attribute that you can add to the tree to describe the volumes associated with each subject, for different brain regions, in your data. \n\nHere, I'm continuing the `acme` example given by Christoph Glur's vignette. \n\nReminder of current tree structure. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nacme\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName\n1  Acme Inc.                       \n2   ¦--Accounting                  \n3   ¦   ¦--New Software            \n4   ¦   °--New Accounting Standards\n5   ¦--Research                    \n6   ¦   ¦--New Product Line        \n7   ¦   °--New Labs                \n8   °--IT                          \n9       ¦--Outsource               \n10      ¦--Go agile                \n11      °--Switch to R             \n```\n\n\n:::\n:::\n\n\nSimple addition of a value under `cost` to a node. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nacme$Accounting$`New Software`$cost <- 1000\n\n# to display appended values, need to use the print function and data column of interest. showing two different ways to get this information\nprint(acme, \"cost\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName cost\n1  Acme Inc.                          NA\n2   ¦--Accounting                     NA\n3   ¦   ¦--New Software             1000\n4   ¦   °--New Accounting Standards   NA\n5   ¦--Research                       NA\n6   ¦   ¦--New Product Line           NA\n7   ¦   °--New Labs                   NA\n8   °--IT                             NA\n9       ¦--Outsource                  NA\n10      ¦--Go agile                   NA\n11      °--Switch to R                NA\n```\n\n\n:::\n\n```{.r .cell-code}\nacme$Get(\"cost\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               Acme Inc.               Accounting             New Software \n                      NA                       NA                     1000 \nNew Accounting Standards                 Research         New Product Line \n                      NA                       NA                       NA \n                New Labs                       IT                Outsource \n                      NA                       NA                       NA \n                Go agile              Switch to R \n                      NA                       NA \n```\n\n\n:::\n:::\n\n\nEven though I only assigned `cost` value to one node, it seems that all the other nodes can also have `cost` printed alongside them, but the values of `cost` are just assumed to be missing for those nodes. \n\nLet's what happens when I assign more values to the same node.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacme$Accounting$`New Software`$cost <- c(2000, 3000)\nprint(acme, \"cost\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName       cost\n1  Acme Inc.                                  \n2   ¦--Accounting                             \n3   ¦   ¦--New Software             2000, 3000\n4   ¦   °--New Accounting Standards           \n5   ¦--Research                               \n6   ¦   ¦--New Product Line                   \n7   ¦   °--New Labs                           \n8   °--IT                                     \n9       ¦--Outsource                          \n10      ¦--Go agile                           \n11      °--Switch to R                        \n```\n\n\n:::\n:::\n\n\nThat seems to replace the previous value on the tree, but shows us that multiple values can be added to the same node as a list. \n\nHow do I append a value onto the node? \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a function called addValue, which takes in a node, a set of values, and append those values to the existing variable \"cost\" associated with the node. append these values to the beginning of the vector \naddValue <- function(node, values) {\n  return(c(values,node$cost))\n}\n\n# using Get to call the function addValue at the specific node \nacme$Accounting$`New Software`$Get(addValue, values = c(1000, 1500))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     New Software\n[1,]         1000\n[2,]         1500\n[3,]         2000\n[4,]         3000\n```\n\n\n:::\n:::\n\n\n\nOkay, this seems to have added values onto the specific node `(acme > Accounting > New Software)`, but did this reflect on the tree? \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacme$Get(\"cost\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`Acme Inc.`\n[1] NA\n\n$Accounting\n[1] NA\n\n$`New Software`\n[1] 2000 3000\n\n$`New Accounting Standards`\n[1] NA\n\n$Research\n[1] NA\n\n$`New Product Line`\n[1] NA\n\n$`New Labs`\n[1] NA\n\n$IT\n[1] NA\n\n$Outsource\n[1] NA\n\n$`Go agile`\n[1] NA\n\n$`Switch to R`\n[1] NA\n```\n\n\n:::\n:::\n\n\n\nDoesn't seem to be reflected on the tree. How do I get it to reflect on the tree? \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# to the acme tree, find the the value cost at any node whose name equal \"New Software\" and add 1000 and 1500 to the existing values in cost \nacme$Do(function(node) node$cost <- addValue(node, c(1000,1500)), \n        filterFun = function(x) x$name == \"New Software\")\nprint(acme, \"cost\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName                   cost\n1  Acme Inc.                                              \n2   ¦--Accounting                                         \n3   ¦   ¦--New Software             1000, 1500, 2000, 3000\n4   ¦   °--New Accounting Standards                       \n5   ¦--Research                                           \n6   ¦   ¦--New Product Line                               \n7   ¦   °--New Labs                                       \n8   °--IT                                                 \n9       ¦--Outsource                                      \n10      ¦--Go agile                                       \n11      °--Switch to R                                    \n```\n\n\n:::\n:::\n\n\nAh! Seems like the `Get` attribute only applies a function to the node temporarily, while the `Do` attribute applies a function to the node permanently and allows it to reflect on the tree. \n\nOkay, just for fun, I'm going to add in some values to this example to reflect scenarios that I might see when working with MRI data. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# at every node that is a leaf not \"New Software\", add a vector with NA and 3 random numbers between 1000 and 3000 to cost. \nacme$Do(function(node) node$cost <- c(NA, sample(1000:3000, size = 3, replace = TRUE)), \n        filterFun = function(x) isLeaf(x))\n\n# create another vector, office, that identifies the ID of different acme offices. \nacme$Do(function(node) node$office <- c(LETTERS[1:4]))\n\nprint(acme, \"cost\", \"office\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName                 cost     office\n1  Acme Inc.                                             A, B, C, D\n2   ¦--Accounting                                        A, B, C, D\n3   ¦   ¦--New Software             NA, 1669, 2872, 1593 A, B, C, D\n4   ¦   °--New Accounting Standards NA, 2129, 2124, 1498 A, B, C, D\n5   ¦--Research                                          A, B, C, D\n6   ¦   ¦--New Product Line         NA, 2673, 2390, 2783 A, B, C, D\n7   ¦   °--New Labs                 NA, 1821, 2466, 1119 A, B, C, D\n8   °--IT                                                A, B, C, D\n9       ¦--Outsource                NA, 1422, 1392, 2479 A, B, C, D\n10      ¦--Go agile                 NA, 2535, 1610, 2490 A, B, C, D\n11      °--Switch to R              NA, 2803, 2663, 2723 A, B, C, D\n```\n\n\n:::\n:::\n\n\nAha! Seems like I can make a new attribute and apply a function to it at the same time (in the case of our `office` variable attribute). \n\nI'm assigning `cost` values to only the leaves because this setup mimics what I usually get with mouse MRI data, where the volume values are only given for the most detailed levels of segmentations (leaves) and added together to create volumes at the highest levels of segmentations. \n\nEspecially with younger mice, many times we can get no good segmentations for regions that are on the mouse atlas, but do not exist in mice at younger ages. Hence why setting `NA` as one of the elements in the vectors for `cost` will mimic the structure of missing volumes as well. \n\n# Summing values in a data tree\n\nIn `RMINC`, the function `addVolumesToHierarchy` \"propagates volumes up the tree by summing.\" This means that the children node of a tree are added together to create volumes for the parent nodes of a tree. I want to understand how this works. Below is my attempt at recreating a similar function with the toy data. \n\nFirst, I'm using the function `Aggregate` to do the summation. I'm still applying this to our `acme` tree example. \n\nAt this point, I am curious how the vectors of `cost` will be added together across different leaves nodes. Perhaps they'll be added together just like how `R` normally adds two vectors? \n\nAdding just two simple vectors for demonstration purposes. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- sample(1:10, replace = TRUE)\nb <- sample(1:10, replace = TRUE)\n\na \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6 6 7 6 6 9 4 7 9 7\n```\n\n\n:::\n\n```{.r .cell-code}\nb \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 10  2  5  6  9  2  9  7  8  5\n```\n\n\n:::\n\n```{.r .cell-code}\na + b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 16  8 12 12 15 11 13 14 17 12\n```\n\n\n:::\n:::\n\n\n\nNow to aggregate the at each node. Here, I want the costs in the children's nodes to be added together and appended to the parent's nodes, until we reach the root node, `acme`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# before Aggregate\nprint(acme, \"cost\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName                 cost\n1  Acme Inc.                                            \n2   ¦--Accounting                                       \n3   ¦   ¦--New Software             NA, 1669, 2872, 1593\n4   ¦   °--New Accounting Standards NA, 2129, 2124, 1498\n5   ¦--Research                                         \n6   ¦   ¦--New Product Line         NA, 2673, 2390, 2783\n7   ¦   °--New Labs                 NA, 1821, 2466, 1119\n8   °--IT                                               \n9       ¦--Outsource                NA, 1422, 1392, 2479\n10      ¦--Go agile                 NA, 2535, 1610, 2490\n11      °--Switch to R              NA, 2803, 2663, 2723\n```\n\n\n:::\n\n```{.r .cell-code}\n# for every node in the tree, sum together the values of the children's nodes and tack them onto the parent's node (start at the children's nodes, or post-order). assign these values to cost\nacme$Do(function(node) node$cost <- Aggregate(node, attribute = \"cost\", aggFun = sum), traversal = \"post-order\")\n```\n:::\n\n\n\nThat doesn't seem to work. Why? What if I just have one value for each cost? \n\n\n::: {.cell}\n\n```{.r .cell-code}\nacme$Do(function(node) node$cost_single <- 1, filterFun = isLeaf)\nprint(acme, \"cost_single\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName cost_single\n1  Acme Inc.                                 NA\n2   ¦--Accounting                            NA\n3   ¦   ¦--New Software                       1\n4   ¦   °--New Accounting Standards           1\n5   ¦--Research                              NA\n6   ¦   ¦--New Product Line                   1\n7   ¦   °--New Labs                           1\n8   °--IT                                    NA\n9       ¦--Outsource                          1\n10      ¦--Go agile                           1\n11      °--Switch to R                        1\n```\n\n\n:::\n\n```{.r .cell-code}\nacme$Do(function(node) node$cost_sum <- Aggregate(node, attribute = \"cost_single\", aggFun = sum), traversal = \"post-order\")\nprint(acme, \"cost_single\", \"cost_sum\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName cost_single cost_sum\n1  Acme Inc.                                 NA        7\n2   ¦--Accounting                            NA        2\n3   ¦   ¦--New Software                       1        1\n4   ¦   °--New Accounting Standards           1        1\n5   ¦--Research                              NA        2\n6   ¦   ¦--New Product Line                   1        1\n7   ¦   °--New Labs                           1        1\n8   °--IT                                    NA        3\n9       ¦--Outsource                          1        1\n10      ¦--Go agile                           1        1\n11      °--Switch to R                        1        1\n```\n\n\n:::\n:::\n\n\n\nNow that works. Seems like `Aggregate` doesn't take vectors. We need to make custom functions for adding the nodes from children to parent. The below function is modified from the function behind `Aggregate` in the `data.tree` package. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddVectors <- function(node) {\n  result <- node$cost # obtain the values associated with cost at each node\n  if(all(is.na(result))) # if all values are NA (you get a vector of NAs, which occur at non-leaf nodes)\n    result <- Reduce(`+`, lapply(node$children, addVectors)) # then find the cost vectors associated with the children of that node and add them together\n  return (result) # this is now the new result of cost summation at the parent node \n}\n```\n:::\n\n\n\n`lapply` is used because cost from `node$children` is a list of vectors, and I want to retain that vector structure when using `Reduce` to add them together. \n\nJust to see this clearly. This will print a list of vectors associated with cost for the children of node `IT`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(FindNode(acme, \"IT\")$children, addVectors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Outsource\n[1]   NA 1422 1392 2479\n\n$`Go agile`\n[1]   NA 2535 1610 2490\n\n$`Switch to R`\n[1]   NA 2803 2663 2723\n```\n\n\n:::\n:::\n\n\n\nAnd if I use `Reduce` to add the vectors together. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nReduce(`+`, lapply(FindNode(acme, \"IT\")$children, addVectors))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   NA 6760 5665 7692\n```\n\n\n:::\n:::\n\n\n\nNow I'm applying the new function I just made. Does it work now? \n\n\n::: {.cell}\n\n```{.r .cell-code}\nacme$Do(function(node) node$cost_sum <- addVectors(node), traversal = \"post-order\")\nprint(acme, \"cost\", \"cost_sum\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName                 cost\n1  Acme Inc.                                            \n2   ¦--Accounting                                       \n3   ¦   ¦--New Software             NA, 1669, 2872, 1593\n4   ¦   °--New Accounting Standards NA, 2129, 2124, 1498\n5   ¦--Research                                         \n6   ¦   ¦--New Product Line         NA, 2673, 2390, 2783\n7   ¦   °--New Labs                 NA, 1821, 2466, 1119\n8   °--IT                                               \n9       ¦--Outsource                NA, 1422, 1392, 2479\n10      ¦--Go agile                 NA, 2535, 1610, 2490\n11      °--Switch to R              NA, 2803, 2663, 2723\n                  cost_sum\n1  NA, 15052, 15517, 14685\n2     NA, 3798, 4996, 3091\n3     NA, 1669, 2872, 1593\n4     NA, 2129, 2124, 1498\n5     NA, 4494, 4856, 3902\n6     NA, 2673, 2390, 2783\n7     NA, 1821, 2466, 1119\n8     NA, 6760, 5665, 7692\n9     NA, 1422, 1392, 2479\n10    NA, 2535, 1610, 2490\n11    NA, 2803, 2663, 2723\n```\n\n\n:::\n:::\n\n\nNice!\n\n# Replacing `NA` values with zero\nSometimes, segmentation is not perfect and will result in `NA` in volumes for certain regions, especially with younger animals. One strategy to deal with this is to replace the `NA` with zero (otherwise the total volumes will be `NA`). I'll try to demonstrate this with the toy example. \n\n Making a function to do so. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreplaceWithZero <- function(node) {\n  result <- node$cost_sum # find the cost vector at the node \n  if(any(is.na(result))) # is there any element on the vector that is NA? \n    result[which(is.na(result))] <- 0 # if that's true, find which element is NA and replace it with zero \n  return(result) # return the result\n}\n```\n:::\n\n\n\nApplying the function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nacme$Do(function(node) node$cost_sum <- replaceWithZero(node))\nprint(acme,\"cost\", \"cost_sum\", \"office\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName                 cost               cost_sum\n1  Acme Inc.                                             0, 15052, 15517, 14685\n2   ¦--Accounting                                           0, 3798, 4996, 3091\n3   ¦   ¦--New Software             NA, 1669, 2872, 1593    0, 1669, 2872, 1593\n4   ¦   °--New Accounting Standards NA, 2129, 2124, 1498    0, 2129, 2124, 1498\n5   ¦--Research                                             0, 4494, 4856, 3902\n6   ¦   ¦--New Product Line         NA, 2673, 2390, 2783    0, 2673, 2390, 2783\n7   ¦   °--New Labs                 NA, 1821, 2466, 1119    0, 1821, 2466, 1119\n8   °--IT                                                   0, 6760, 5665, 7692\n9       ¦--Outsource                NA, 1422, 1392, 2479    0, 1422, 1392, 2479\n10      ¦--Go agile                 NA, 2535, 1610, 2490    0, 2535, 1610, 2490\n11      °--Switch to R              NA, 2803, 2663, 2723    0, 2803, 2663, 2723\n       office\n1  A, B, C, D\n2  A, B, C, D\n3  A, B, C, D\n4  A, B, C, D\n5  A, B, C, D\n6  A, B, C, D\n7  A, B, C, D\n8  A, B, C, D\n9  A, B, C, D\n10 A, B, C, D\n11 A, B, C, D\n```\n\n\n:::\n:::\n\n\nThat works!\n\n# Finding mean cost associated with each office \n\nMaking a function to find the mean cost \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetMean <- function(node) {\n  result <- node$cost_sum \n  return(mean(result))\n}\n```\n:::\n\n\n\nApplying the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacme$Do(function(node) node$meanCost <- getMean(node))\nprint(acme, \"meanCost\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName meanCost\n1  Acme Inc.                        11313.50\n2   ¦--Accounting                    2971.25\n3   ¦   ¦--New Software              1533.50\n4   ¦   °--New Accounting Standards  1437.75\n5   ¦--Research                      3313.00\n6   ¦   ¦--New Product Line          1961.50\n7   ¦   °--New Labs                  1351.50\n8   °--IT                            5029.25\n9       ¦--Outsource                 1323.25\n10      ¦--Go agile                  1658.75\n11      °--Switch to R               2047.25\n```\n\n\n:::\n:::\n\n\n# Building models \n\n`RMINC` has a few built in modeling functions, like `mincLm` and `mincLmer`. How might these functions work? I'll try to build something similar with the toy example here. \n\nFirst, I want to see if linear modeling with a data tree requires that I account for the location of a node on a tree (i.e. is it a child, parent, dependent on any other nodes?). Given that `RMINC` can create linear models and append results directly on the tree, I used the functions for doing so in `RMINC` as my reference. \n\nI'm reading through the source code of the relevant functions in `RMINC`. To keep this report short, I will not print out the results, but the functions to read the source codes are as followed. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(RMINC)\ngetAnywhere(hanatLm)\ngetAnywhere(anatLm)\n```\n:::\n\n\n\nBased on the source codes of these functions, it doesn't seem like I need to define hierarchical relationships between the nodes in the linear models. Proceed as usual to make a function for doing linear models at every node. \n\nI want to model the relationship between the total cost (`cost_sum`) and each acme `office`. The results will be very wonky. I didn't put in any underlying trends for the fake data. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmakeLm <- function(node, attribute_y, attribute_x) {\n  \n  y <- node[[attribute_y]] # grab attribute_y associated with each node\n  x <- node[[attribute_x]] # grab attribute_x associated with each node \n  \n  model <- lm(y ~ x) # model the two variables \n  \n  model_summary <- summary(model) # print summary of the model\n  p_val <- coef(model_summary)[2, \"Pr(>|t|)\"] # grab p-value associated with office \n  \n  return(p_val)\n}\n```\n:::\n\n\n\nNow apply the function. First, running it with `Get` so that the tree won't be permanently changed.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nacme$Get(function(node) node$pval <- makeLm(node, attribute_y = \"cost_sum\", attribute_x = \"office\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               Acme Inc.               Accounting             New Software \n                     NaN                      NaN                      NaN \nNew Accounting Standards                 Research         New Product Line \n                     NaN                      NaN                      NaN \n                New Labs                       IT                Outsource \n                     NaN                      NaN                      NaN \n                Go agile              Switch to R \n                     NaN                      NaN \n```\n\n\n:::\n:::\n\n\nOf course the results would look weird. I only have one value per office after all. Can't do any comparisons there. But seems like the function ran correctly at least. \n\nJust for fun, I'll make a new numeric, random variable, to run in a model. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacme$Do(function(node) node$randomNum <- sample(1:1000, 4))\nprint(acme, \"cost_sum\", \"randomNum\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          levelName               cost_sum          randomNum\n1  Acme Inc.                        0, 15052, 15517, 14685 294, 228, 454, 279\n2   ¦--Accounting                      0, 3798, 4996, 3091 532, 591, 694, 699\n3   ¦   ¦--New Software                0, 1669, 2872, 1593 550, 464, 416, 481\n4   ¦   °--New Accounting Standards    0, 2129, 2124, 1498  306, 767, 601, 64\n5   ¦--Research                        0, 4494, 4856, 3902  342, 84, 598, 586\n6   ¦   ¦--New Product Line            0, 2673, 2390, 2783 956, 948, 428, 717\n7   ¦   °--New Labs                    0, 1821, 2466, 1119  927, 437, 586, 13\n8   °--IT                              0, 6760, 5665, 7692 510, 701, 991, 206\n9       ¦--Outsource                   0, 1422, 1392, 2479  272, 952, 35, 152\n10      ¦--Go agile                    0, 2535, 1610, 2490 695, 576, 926, 132\n11      °--Switch to R                 0, 2803, 2663, 2723 912, 253, 895, 787\n```\n\n\n:::\n:::\n\n\n\nRunning another model on the data tree. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacme$Get(function(node) node$pval_randomNum <- makeLm(node, attribute_y = \"cost_sum\", attribute_x = \"randomNum\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               Acme Inc.               Accounting             New Software \n              0.83038361               0.23949966               0.00501231 \nNew Accounting Standards                 Research         New Product Line \n              0.46061489               0.85684164               0.56481047 \n                New Labs                       IT                Outsource \n              0.66859012               0.94934781               0.92994499 \n                Go agile              Switch to R \n              0.50779430               0.53444781 \n```\n\n\n:::\n:::\n\n\n\nYay works. \n\n# Takeaways\nIn this toy example, I tried to emulate some of the more common data tree structures/operations that one can do in the hierarchical anatomy of `RMINC` to get a better understanding of how to manipulate the hierarchical data tree in `RMINC`. \n\nSome other operations that one might do, which I did not demonstrate here, include pruning a tree to retain only the parent nodes (i.e. you might want just cerebellar volume, but not subregions of the cerebellum). To do this, one could use the `Prune` function, or using the examples for how to make functions for data trees nodes, one could make up a function to remove nodes with names equal to certain children nodes. \n\nI also learned that whether the data is in tree or data table formats, running linear models on the nodes work the same way.\n\nPerhaps the main advantage of using a data tree then, in the context of mouse MRI, is that the volume of small subregions can be quickly calculated and summed to make the volumes of larger regions. Otherwise, analyses remain largely the same regardless of whether it's a tree or data table. \n\nLastly, when using `RMINC`, the volumes are appended onto the data tree, but subject meta information are located in a separate CSV. It's important that the order of subjects in the CSV matches up with the order of subject values listed in the tree (i.e. the vector of values for cerebellum might be `c(volume_1, volume_2, volume_3)`. That means the meta information CSV has to also list subjects as `c(subject_1, subject_2, subject_3)`).  \n\nTo check the order for how subjects volumes are appended onto a tree, one could do the following: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# find the output segmentation file for each subject, labeled with suffixes _voted\nsegmentation_files <- system(\"find /well/lerch/users/xrs336/all-cohorts-test-run-maget-070325/ -type f -name '*_voted.mnc'\", intern = TRUE))\n\n# grabbing volumes of the segmentation files. the data is a matrix of volume columns and an input filename column.\nallvols <- anatGetAll(filenames = seg_files, defs = defs, method = \"labels\")\n\n# grabbing just the vector of filenames from the input data matrix\ntree_order <- data.frame(filename = attributes(allvols)$input)\n\n# this can now be used to ensure that the CSV containing the subject meta information has a filename column that follows the exact filename order as the matrix of volumes that will be appended to the data tree\nleft_join(tree_order, meta_info_csv, by = \"filename\")\n```\n:::\n\n\n\n# Reference\nTo understand what attributes are associated with each node, simply find the node of interest, follow it with `$`, and a pop up of attributes options will follow. \n\nUse the [data.tree documentation] (https://cran.r-project.org/web/packages/data.tree/data.tree.pdf) to understand the function of each attribute. ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}